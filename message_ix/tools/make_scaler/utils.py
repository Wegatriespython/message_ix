import os

import numpy as np
import pandas as pd


def filter_df(data, bounds):
    """Extracts matrix elements with coefficient outliers.

    This function extracts elements from a matrix where
    the coefficients deviate from a specified threshold.

    Parameters:
    -----------
    data : pandas DataFrame
        The coefficient matrix, typically generated by
        the mps_sum function in LPDiag.
    bounds: int or list of 2 integers
        Exponent threshold used to identify outlier coefficients.
        If a single integer is provided, the bounds are set to +/- that value.
        If a list of 2 integers is provided, they represent the lower and
        upper bounds of the threshold.

    Examples:
    ---------
    # Extract elements with coefficient exponents deviating beyond +/-3
    extracted_data = filter_df(data_matrix, 3)

    # Extract elements with coefficients exponents deviating
    # beyond the range of -2 to 2
    extracted_data = extract_outliers(data_matrix, [-2, 2])
    """

    if isinstance(bounds, int):
        lo_bound = -bounds
        up_bound = bounds
    else:
        lo_bound = bounds[0]
        up_bound = bounds[1]

    arr = data["val"].to_numpy()
    mask = (arr <= lo_bound) | (arr >= up_bound)
    return data.loc[mask]


def make_logdf(data):
    """
    Optimized log10 of the absolute non zero value element of dataframe.

    """
    arr = data["val"].to_numpy()
    mask = arr != 0
    log_arr = np.zeros_like(arr, dtype=float)
    log_arr[mask] = np.log10(np.abs(arr[mask]))
    return pd.DataFrame({"val": log_arr}, index=data.index)


def get_lvl_ix(data, lvl):
    """
    To get level index from coefficient matrix.

    Parameters:
    -----------
    data : pandas DataFrame
        The coefficient matrix, typically generated by
        the mps_sum function in LPDiag.
    lvl : int or str
        0 or "row" for rows and 1 or "col" for columns

    """
    return data.index.get_level_values(lvl)


def show_range(data, pretext):
    """
    To displace coefficient exponents range.

    """

    log_absdf = make_logdf(data)

    print(
        f"{pretext}:",
        "[",
        np.int32(np.min(log_absdf)),  # lower bound
        "|",
        np.int32(np.max(log_absdf)),  # upper bound
        "]",
    )


def get_scaler_args(
    scenario_ref_model=None, scenario_ref_scenario=None, model="", scenario=""
):
    """
    Function to make gams argument for scaling

    """
    if not scenario_ref_model:
        strings = ["MsgScaler", model, scenario]
    else:
        strings = ["MsgScaler", scenario_ref_model, scenario_ref_scenario]

    file_name = "_".join(s.replace(" ", "_") for s in strings)
    prescale_args_dir = os.path.join(f"message_ix/model/scaler/{file_name}.gms")

    if os.path.exists(prescale_args_dir):
        return f"--scaler={file_name}"
    else:
        print(f" I am here {os.getcwd()}")
        print(f"could not find file at {prescale_args_dir} ")
        print("The referred scenario doesn't have prescaler file!")
        print("Please use make_prescaler() function to create one")


def replace_spaces_in_quotes(match):
    inner_text = match.group(1)
    return f"'{inner_text.replace(' ', '___')}'"


def return_spaces_in_quotes(match):
    inner_text = match.group(1)
    return f"'{inner_text.replace('---', ' ')}'"


def _process_scaling_step(matrix, scalers, s, bounds, counter, display_range):
    """Process a single scaling step for rows or columns using optimized operations."""
    log_absmatrix = make_logdf(matrix)
    log_absmatrix_solv = filter_df(log_absmatrix, bounds)

    objective_ix = "_obj" if s == "row" else "constobj"
    levels_solv = [
        lvl for lvl in get_lvl_ix(log_absmatrix_solv, s) if lvl != objective_ix
    ]

    if levels_solv:
        grp = log_absmatrix["val"].groupby(level=s)
        bounds_df = grp.agg(["min", "max"]).astype(int)
        mids = ((bounds_df["min"] + bounds_df["max"]) / 2).astype(int)
        exps = mids if s == "row" else -mids
        SFs = (10.0**exps).to_dict()
        SFs = {k: v for k, v in SFs.items() if k in levels_solv}
    else:
        SFs = {}

    return_index = list(set(get_lvl_ix(log_absmatrix, s)))
    multiplier = 1 if counter == 0 else scalers[s].reindex(return_index).fillna(1)

    step_scaler = pd.DataFrame(data=SFs, index=["val"]).transpose()
    step_scaler.index.name = s
    step_scaler = step_scaler.reindex(return_index).fillna(1)

    scalers[s] = step_scaler.mul(multiplier)
    matrix = matrix.div(step_scaler) if s == "row" else matrix.mul(step_scaler)
    return matrix
